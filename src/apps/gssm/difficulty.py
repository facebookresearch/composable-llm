"""
Utility to estimate difficulty levels of GSSM configurations.

License
-------
This source code is licensed under the terms specified in the `LICENSE` file,
located in the root directory of this repository.

@ 2025, Meta
"""

# %%
import zlib
from typing import Any

import matplotlib.pyplot as plt
import numpy as np

from nanollama.data import gssm
from nanollama.utils import initialize_nested_object


def get_compression_ratio(batch: np.ndarray, level: int = 9) -> float:
    """
    Get the compression ratio of a sequence.
    Estimate the entropy of a sequence by compressing it with gzip.

    Parameters
    ----------
    seq:
        Sequence to estimate the entropy of.
    level:
        Compression level to use, by default 9.

    Returns
    -------
    Entropy estimate.
    """
    compressed_data = zlib.compress(batch.tobytes(), level=level)
    return len(compressed_data) / batch.size


def estimate_config_difficulty(
    gssm_config: dict[str, Any], bsz: int = 256, seq_len: int = 1024, level: int = 9, seed: float = 0
) -> float:
    """
    Estimate the difficulty of a GSSM configuration by compressing sequences generated by it.

    Parameters
    ----------
    gssm_config:
        Configuration of the GSSM.
    bsz:
        Batch size of sequences to generate, by default 256.
    seq_len:
        Length of sequences to generate, by default 1024.
    level:
        Compression level to use, by default 9.
    """
    config = initialize_nested_object(gssm.GSSMConfig, gssm_config, inplace=False)

    nodes = gssm.build_gssm(config, np.random.default_rng(seed=seed))
    batch = np.empty((bsz, seq_len), dtype=int)

    nodes["X"].initialize(bsz)
    for t in range(seq_len):
        nodes["X"].evolve()
        batch[:, t] = nodes["X"].state

    return get_compression_ratio(batch, level=level)


gssm_config_base = {
    "nodes": [
        {"name": "Z1", "state_dim": 2, "parents": [], "alpha": 0.3},
        {"name": "Z2", "state_dim": 2, "parents": ["Z1"], "alpha": 0.01},
        {"name": "Z4", "state_dim": 2, "parents": ["Z2", "Z1"], "alpha": 0.1},
        {
            "name": "X",
            "state_dim": 16,
            "parents": ["Z1", "Z4"],
            "alpha": 0.3,
        },
        # {"name": "Z1", "state_dim": 2, "parents": [], "alpha": 1e-1},
        # {"name": "Z2", "state_dim": 2, "parents": ["Z1"], "alpha": 1e-1},
        # {"name": "Z4", "state_dim": 2, "parents": ["Z2", "Z1"], "alpha": 1e-1},
        # {
        #     "name": "X",
        #     "state_dim": 16,
        #     "parents": ["Z1", "Z4"],
        #     "alpha": 1e-2,
        # },
    ]
}


def gssm_config_template(alpha_X: float, alpha_Z: float) -> dict[str, Any]:
    return {
        "nodes": [
            {"name": "Z1", "state_dim": 2, "parents": [], "alpha": 0.3},
            {"name": "Z2", "state_dim": 2, "parents": ["Z1"], "alpha": 0.01},
            {"name": "Z4", "state_dim": 2, "parents": ["Z2", "Z1"], "alpha": 0.1},
            {
                "name": "X",
                "state_dim": 16,
                "parents": ["Z1", "Z4"],
                "alpha": float(alpha),
            },
            # {"name": "Z1", "state_dim": 2, "parents": [], "alpha": alpha_Z},
            # {"name": "Z2", "state_dim": 2, "parents": ["Z1"], "alpha": alpha_Z},
            # {"name": "Z4", "state_dim": 2, "parents": ["Z2", "Z1"], "alpha": alpha_Z},
            # {
            #     "name": "X",
            #     "state_dim": 16,
            #     "parents": ["Z1", "Z4"],
            #     "alpha": alpha_X,
            # },
        ]
    }


# # %%
# def objective(alpha_Z: float) -> float:
#     cfg = gssm_config_template(alpha_X=1e-2, alpha_Z=alpha_Z)
#     new_H = estimate_config_difficulty(cfg, level=1)
#     return (new_H - base_H) ** 2


# # minimize
# result = minimize_scalar(objective, bounds=(0.0001, 10), method="bounded")
# print(result)

# %%

bsz = 2048
seq_len = 1024
level = 9
hs = []
alphas = np.logspace(-3, 1, 50)

base_H = estimate_config_difficulty(gssm_config_base, bsz=bsz, seq_len=seq_len, level=level)

for alpha in alphas:
    cfg = gssm_config_template(alpha_X=1e-2, alpha_Z=alpha)
    new_H = estimate_config_difficulty(cfg, bsz=bsz, seq_len=seq_len, level=level)
    hs.append(new_H)


# %%

plt.plot(alphas, [h - base_H for h in hs])
# truth
plt.axvline(gssm_config_base["nodes"][-1]["alpha"])
plt.xscale("log")
plt.grid()
# plt.yscale("log")

# %%
